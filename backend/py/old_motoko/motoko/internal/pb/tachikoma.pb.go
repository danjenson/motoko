// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tachikoma.proto

package pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("tachikoma.proto", fileDescriptor_7fccddf1efc589ab) }

var fileDescriptor_7fccddf1efc589ab = []byte{
	// 144 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2f, 0x49, 0x4c, 0xce,
	0xc8, 0xcc, 0xce, 0xcf, 0x4d, 0xd4, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x2a, 0x48, 0x92,
	0xe2, 0x2e, 0xa9, 0x2c, 0x48, 0x2d, 0x86, 0x08, 0x18, 0x2d, 0x66, 0xe4, 0xe2, 0x0c, 0x81, 0x29,
	0x12, 0xd2, 0xe3, 0x62, 0xf5, 0xcc, 0x4b, 0x4b, 0x2d, 0x12, 0x12, 0xd0, 0x2b, 0x48, 0xd2, 0x03,
	0x33, 0x83, 0x52, 0x0b, 0x4b, 0x53, 0x8b, 0x4b, 0xa4, 0x04, 0x91, 0x44, 0x8a, 0x0b, 0xf2, 0xf3,
	0x8a, 0x53, 0x35, 0x18, 0x41, 0xea, 0x7d, 0x52, 0x13, 0x8b, 0xf2, 0x20, 0xea, 0xc1, 0x4c, 0x14,
	0xf5, 0x50, 0x11, 0xb8, 0x7a, 0x33, 0x2e, 0xf6, 0x80, 0xa2, 0xd4, 0x94, 0xcc, 0xe4, 0x12, 0x21,
	0x21, 0x90, 0x3c, 0x94, 0x03, 0xd3, 0x23, 0x8c, 0x22, 0x06, 0xd3, 0x65, 0xc0, 0x98, 0xc4, 0x06,
	0x76, 0xac, 0x31, 0x20, 0x00, 0x00, 0xff, 0xff, 0xbd, 0xc9, 0x94, 0xb8, 0xd0, 0x00, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TachikomaClient is the client API for Tachikoma service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TachikomaClient interface {
	Infer(ctx context.Context, opts ...grpc.CallOption) (Tachikoma_InferClient, error)
	Learn(ctx context.Context, opts ...grpc.CallOption) (Tachikoma_LearnClient, error)
	Predict(ctx context.Context, opts ...grpc.CallOption) (Tachikoma_PredictClient, error)
}

type tachikomaClient struct {
	cc *grpc.ClientConn
}

func NewTachikomaClient(cc *grpc.ClientConn) TachikomaClient {
	return &tachikomaClient{cc}
}

func (c *tachikomaClient) Infer(ctx context.Context, opts ...grpc.CallOption) (Tachikoma_InferClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Tachikoma_serviceDesc.Streams[0], "/pb.Tachikoma/Infer", opts...)
	if err != nil {
		return nil, err
	}
	x := &tachikomaInferClient{stream}
	return x, nil
}

type Tachikoma_InferClient interface {
	Send(*InferRequest) error
	CloseAndRecv() (*InferResponse, error)
	grpc.ClientStream
}

type tachikomaInferClient struct {
	grpc.ClientStream
}

func (x *tachikomaInferClient) Send(m *InferRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tachikomaInferClient) CloseAndRecv() (*InferResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(InferResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tachikomaClient) Learn(ctx context.Context, opts ...grpc.CallOption) (Tachikoma_LearnClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Tachikoma_serviceDesc.Streams[1], "/pb.Tachikoma/Learn", opts...)
	if err != nil {
		return nil, err
	}
	x := &tachikomaLearnClient{stream}
	return x, nil
}

type Tachikoma_LearnClient interface {
	Send(*LearnRequest) error
	CloseAndRecv() (*LearnResponse, error)
	grpc.ClientStream
}

type tachikomaLearnClient struct {
	grpc.ClientStream
}

func (x *tachikomaLearnClient) Send(m *LearnRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tachikomaLearnClient) CloseAndRecv() (*LearnResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(LearnResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tachikomaClient) Predict(ctx context.Context, opts ...grpc.CallOption) (Tachikoma_PredictClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Tachikoma_serviceDesc.Streams[2], "/pb.Tachikoma/Predict", opts...)
	if err != nil {
		return nil, err
	}
	x := &tachikomaPredictClient{stream}
	return x, nil
}

type Tachikoma_PredictClient interface {
	Send(*PredictRequest) error
	Recv() (*PredictResponse, error)
	grpc.ClientStream
}

type tachikomaPredictClient struct {
	grpc.ClientStream
}

func (x *tachikomaPredictClient) Send(m *PredictRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tachikomaPredictClient) Recv() (*PredictResponse, error) {
	m := new(PredictResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TachikomaServer is the server API for Tachikoma service.
type TachikomaServer interface {
	Infer(Tachikoma_InferServer) error
	Learn(Tachikoma_LearnServer) error
	Predict(Tachikoma_PredictServer) error
}

func RegisterTachikomaServer(s *grpc.Server, srv TachikomaServer) {
	s.RegisterService(&_Tachikoma_serviceDesc, srv)
}

func _Tachikoma_Infer_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TachikomaServer).Infer(&tachikomaInferServer{stream})
}

type Tachikoma_InferServer interface {
	SendAndClose(*InferResponse) error
	Recv() (*InferRequest, error)
	grpc.ServerStream
}

type tachikomaInferServer struct {
	grpc.ServerStream
}

func (x *tachikomaInferServer) SendAndClose(m *InferResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tachikomaInferServer) Recv() (*InferRequest, error) {
	m := new(InferRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Tachikoma_Learn_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TachikomaServer).Learn(&tachikomaLearnServer{stream})
}

type Tachikoma_LearnServer interface {
	SendAndClose(*LearnResponse) error
	Recv() (*LearnRequest, error)
	grpc.ServerStream
}

type tachikomaLearnServer struct {
	grpc.ServerStream
}

func (x *tachikomaLearnServer) SendAndClose(m *LearnResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tachikomaLearnServer) Recv() (*LearnRequest, error) {
	m := new(LearnRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Tachikoma_Predict_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TachikomaServer).Predict(&tachikomaPredictServer{stream})
}

type Tachikoma_PredictServer interface {
	Send(*PredictResponse) error
	Recv() (*PredictRequest, error)
	grpc.ServerStream
}

type tachikomaPredictServer struct {
	grpc.ServerStream
}

func (x *tachikomaPredictServer) Send(m *PredictResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tachikomaPredictServer) Recv() (*PredictRequest, error) {
	m := new(PredictRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Tachikoma_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Tachikoma",
	HandlerType: (*TachikomaServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Infer",
			Handler:       _Tachikoma_Infer_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Learn",
			Handler:       _Tachikoma_Learn_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Predict",
			Handler:       _Tachikoma_Predict_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "tachikoma.proto",
}
